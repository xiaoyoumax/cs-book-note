## 竞态条件 - race condition
```
1. 即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数？

2. 如何保证正在执行成员函数期间，对象不会在另一个线程被析构？

3. 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？

智能指针yyds~
```

## 线程安全
```
1. 多个线程同时访问时，其表现出正确的行为。

2. 无论操作系统如何调度这些线程，无论这些线程的执行顺序如何交织。

3. 调用端代码无须额外的同步或其他协调动作。
```

## C++内存问题
```
1. 缓冲区溢出 - buffer overrun 😢

用std::vector<char>/std::string或自己编写Buffer Class来管理缓冲区，自动记住用缓冲区的长度，并通过成员函数而不是裸指针来修改缓冲区。

2. 空悬指针/野指针 😢😢😢

用shared_ptr/weak_ptr。

智能指针：一旦某个对象不再被引用，系统会立刻回收内存。这通常发生在关键任务完成后的清理时期，不会影响关键任务的实时性，同时，内存里所有的对象都是有用的，绝对没有垃圾空占内存。

3. 重复释放 - double delete 😢😢😢

用scoped_ptr，只在对象析构的时候释放一次。


4. 内存泄漏 - memory leak 😢😢😢

用scoped_ptr，对象析构的时候自动释放内存。

5. 不配对的new[]/delete 😢😢😢

把new[]统统替换成std::vector/scoped_array

6. 内存碎片 - memory fragmentation 😢😢


```

